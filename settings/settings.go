package settings

import (
	"log"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/credli/com"
	"github.com/go-macaron/session"
	_ "github.com/go-macaron/session/redis"
	"gopkg.in/ini.v1"

	"github.com/credli/hcsg/bindata"
)

type Scheme string

const (
	HTTP  Scheme = "http"
	HTTPS Scheme = "https"
)

var (
	AppDataPath = "data"

	// Generated by Makefile
	AppVer       string
	BuildTime    string
	BuildGitHash string

	// Server settings
	AppName            string
	AppURL             string
	AppSubURL          string
	Protocol           Scheme
	Domain             string
	HttpAddr, HttpPort string
	CertFile, KeyFile  string
	StaticRootPath     string
	LogRootPath        string
	DisableRouterLog   bool

	// Security settings
	SecretKey          string
	CookieUserName     string
	CookieRememberName string
	LoginRememberDays  int

	// Database settings
	UseSQLite3 bool
	UseODBC    bool

	Cfg          *ini.File
	AppPath      string
	CustomPath   string // Custom directory path.
	CustomConf   string
	ProdMode     bool
	HasRobotsTxt bool

	// Attachment settings.
	AttachmentPath         string
	AttachmentAllowedTypes string
	AttachmentMaxSize      int64
	AttachmentMaxFiles     int
	AttachmentEnabled      bool

	// Time settings.
	TimeFormat string

	// Session settings.
	SessionConfig session.Options
)

func execPath() (string, error) {
	file, err := exec.LookPath(os.Args[0])
	if err != nil {
		return "", err
	}
	return filepath.Abs(file)
}

// WorkDir returns absolute path of work directory.
func WorkDir() (string, error) {
	wd := os.Getenv("HCSG_WORK_DIR")
	if len(wd) > 0 {
		return wd, nil
	}

	i := strings.LastIndex(AppPath, "/")
	if i == -1 {
		return AppPath, nil
	}
	return AppPath[:i], nil
}

func forcePathSeparator(path string) {
	if strings.Contains(path, "\\") {
		log.Fatal(4, "Do not use '\\' or '\\\\' in paths, instead, please use '/' in all places")
	}
}

func init() {
	var err error
	if AppPath, err = execPath(); err != nil {
		log.Printf("ERROR: failed to get app path: %v\n", err)
	}
}

func NewContext() {
	workDir, err := WorkDir()
	if err != nil {
		log.Printf("ERROR: Failed to get working directory: %v\n", err)
	}

	Cfg, err = ini.Load(bindata.MustAsset("conf/app.ini"))
	if err != nil {
		log.Printf("ERROR: Failed to parse 'conf/app.ini': %v", err)
	}

	CustomPath = os.Getenv("HCSG_CUSTOM")
	if len(CustomPath) == 0 {
		CustomPath = workDir + "/custom"
	}

	if len(CustomConf) == 0 {
		CustomConf = CustomPath + "/conf/app.ini"
	}

	if com.IsFile(CustomConf) {
		if err = Cfg.Append(CustomConf); err != nil {
			log.Printf("ERROR: Failed to load custom conf '%s': %v", CustomConf, err)
		}
	} else {
		log.Printf("WARN: Custom config file (%s) was not found, ignore this if you're running first time.\n", CustomConf)
	}

	Cfg.NameMapper = ini.AllCapsUnderscore

	LogRootPath = Cfg.Section("log").Key("ROOT_PATH").MustString(path.Join(workDir, "log"))
	forcePathSeparator(LogRootPath)

	sec := Cfg.Section("server")
	AppName = sec.Key("APP_NAME").MustString("HC Source Guide")
	AppURL = sec.Key("APP_URL").MustString("http://localhost:8881/")
	if AppURL[len(AppURL)-1] != '/' {
		AppURL += "/"
	}

	u, err := url.Parse(AppURL)
	if err != nil {
		log.Printf("ERROR: Invalid APP_URL(%s): %s", AppURL, err)
	}
	AppSubURL = strings.TrimSuffix(u.Path, "/")

	Protocol = HTTP
	if sec.Key("PROTOCOL").String() == "https" {
		Protocol = HTTPS
		CertFile = sec.Key("CERT_FILE").String()
		KeyFile = sec.Key("KEY_FILE").String()
	}
	Domain = sec.Key("DOMAIN").MustString("localhost")
	HttpAddr = sec.Key("HTTP_ADDR").MustString("0.0.0.0")
	HttpPort = sec.Key("HTTP_PORT").MustString("8881")

	StaticRootPath = sec.Key("STATIC_ROOT_PATH").MustString(workDir + "/public")
	DisableRouterLog = sec.Key("DISABLE_ROUTER_LOG").MustBool(false)

	SecretKey = sec.Key("SECRET_KEY").String()
	CookieUserName = sec.Key("COOKIE_USER_NAME").MustString("hcsg_user")
	CookieRememberName = sec.Key("COOKIE_REMEMBER_NAME").MustString("hcsg_remember")
	LoginRememberDays = sec.Key("LOGIN_REMEMBER_DAYS").MustInt(1)

	HasRobotsTxt = com.IsFile(path.Join(CustomPath, "robots.txt"))

	sec = Cfg.Section("attachment")
	AttachmentPath = sec.Key("PATH").MustString(path.Join(AppDataPath, "attachments"))
	if !filepath.IsAbs(AttachmentPath) {
		AttachmentPath = path.Join(workDir, AttachmentPath)
	}
	AttachmentAllowedTypes = strings.Replace(sec.Key("ALLOWED_TYPES").MustString("image/jpeg,image/png"), "|", ",", -1)
	AttachmentMaxSize = sec.Key("MAX_SIZE").MustInt64(4)
	AttachmentMaxFiles = sec.Key("MAX_FILES").MustInt(5)
	AttachmentEnabled = sec.Key("ENABLE").MustBool(true)

	TimeFormat = map[string]string{
		"ANSIC":       time.ANSIC,
		"UnixDate":    time.UnixDate,
		"RubyDate":    time.RubyDate,
		"RFC822":      time.RFC822,
		"RFC822Z":     time.RFC822Z,
		"RFC850":      time.RFC850,
		"RFC1123":     time.RFC1123,
		"RFC1123Z":    time.RFC1123Z,
		"RFC3339":     time.RFC3339,
		"RFC3339Nano": time.RFC3339Nano,
		"Kitchen":     time.Kitchen,
		"Stamp":       time.Stamp,
		"StampMilli":  time.StampMilli,
		"StampMicro":  time.StampMicro,
		"StampNano":   time.StampNano,
	}[Cfg.Section("time").Key("FORMAT").MustString("RFC1123")]
}

func newSessionService() {
	SessionConfig.Provider = Cfg.Section("session").Key("PROVIDER").In("memory",
		[]string{"memory", "file", "redis", "mysql"})
	SessionConfig.ProviderConfig = strings.Trim(Cfg.Section("session").Key("PROVIDER_CONFIG").String(), "\" ")
	SessionConfig.CookieName = Cfg.Section("session").Key("COOKIE_NAME").MustString("hcsg")
	SessionConfig.CookiePath = AppSubURL
	SessionConfig.Secure = Cfg.Section("session").Key("COOKIE_SECURE").MustBool()
	SessionConfig.Gclifetime = Cfg.Section("session").Key("GC_INTERVAL_TIME").MustInt64(86400)
	SessionConfig.Maxlifetime = Cfg.Section("session").Key("SESSION_LIFE_TIME").MustInt64(86400)

	log.Println("Session Service Enabled")
}

func NewServices() {
	newSessionService()
}
